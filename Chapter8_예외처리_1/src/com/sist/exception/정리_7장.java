package com.sist.exception;
/*
 * 		final 클래스 => 종단 클래스
 * 		=> 확장해서 사용 불가(있는 그대로 사용) => 상속을 내릴 수 없다(==상위 클래스가 될 수 없다)
 * 		-- 기본 라이브러리 --
 * 		java.lang
 * 		java.util
 * 		java.io
 * 		java.net
 * 		java.text
 * 		-----------------
 * 		java.sql : 오라클 연동
 * 		javax.http.servlet.* : 브라우저 연동
 * 		javax.xml...
 * 
 * 		4. 오버라이딩 => 변경해서 사용(다형성)
 * 		객체지향의 3대 요소
 * 		 1. 데이터 보호 목적
 * 			캡슐화 : 변수를 은닉화(private) => 메소드를 통해서 접근 가능하게 만든다(getter/setter)
 * 				=> 변수는 2가지 기능만 수행
 * 				메모리 저장 / 메모리에서 데이터 읽기
 * 				=> 모든 멤버변수 : private / 모든 메소드(생성자) : public(=> 다른 클래스와 연결이 가능하게)
 * 		 2. 재사용하는 목적 : 상속, 포함 ==> 클래스 크기 결정 => 형변환 가능
 * 			class A
 * 			class B extends A => A가 가지고 있는 모든 내용을 가지고 옴
 * 								 A의 내용을 변경해서 사용, 추가가 가능하다
 * 			class A
 * 			{
 * 				B b = new B(); => 특별한 경우가 아니면 재정의하지 않는다
 * 			}
 * 			class B
 * 			묵시적 형변환(자동)
 * 			명시적 형변환(강제) => 라이브러리에서 많이 사용
 * 							  
 * 		 3. 수정, 추가 목적(유지보수)
 * 				추가(오버로딩)  수정(오버라이딩) => 메소드 관련
 * 			사용처 : 생성자 / 인터페이스, 추상클래스
 * 			상속
 * 			1) 호출 ==> 상위클래스의 생성자가 먼저 호출(기본생성자)
 * 			2) 예외조건 : static, 생성자, 초기화블록, private
 * 
 * 			class A
 * 			class B extends A
 * 			class D extends B
 * 			class E extends B
 * 			-------------------------------------------
 * 			A a = new A() / new B()
 * 			B b = new B() / new D() / new E()
 * 			-------------------------------------------
 * 			B b = (B)new A(); (X) => ClassCastException
 * 			A a = new B();
 * 			B b = (B)a;
 * 		----------------------------------------------------------------
 * 		클래스의 종류
 * 		추상클래스
 * 		인터페이스 => 추상클래스의 단점을 보완(클래스와 동일하게 취급한다)
 * 		 클래스(단일) / 인터페이스(다중)
 * 		-설계도(구현이 안된 상태) => 미완성 클래스(자신이 메모리 할당 못함)
 * 		-여러개의 관련된 클래스를 모아서 한개의 객체명으로 제어
 * 		-----------------------------------------------------------
 * 						추상클래스					인터페이스
 * 		-----------------------------------------------------------
 * 		상속관계			단일 상속					다중 상속
 * 		-----------------------------------------------------------
 * 		상속키워드			extends				   implements
 * 		-----------------------------------------------------------
 * 		멤버변수			인스턴스변수			  상수형변수만 사용
 * 						 정적변수
 * 		-----------------------------------------------------------
 * 		메소드		   구현된 메소드			  구현이 안된 메소드
 * 					 구현이 안된 메소드
 * 		-----------------------------------------------------------
 * 		기법				오버라이딩					오버라이딩
 * 		-----------------------------------------------------------
 * 		형식	[접근지정어] abstract className		[접근지정어] interface InterfaceName
 * 			{								{
 * 				------------------------		------------------------
 * 				변수								변수선언 (성수형변수)
 * 				 인스턴스변수 / static변수			 int a = 10; => 값을 명시적으로 지정
 * 				------------------------		 =>(public static final) int a = 10;
 * 				메소드							------------------------
 * 				 구현된 메소드						구현이 안된 메소드 목록
 * 				 구현이 안된 메소드(선언)				 void display();
 * 				------------------------		 =>(public abstract) void display();
 * 				생성자 => 오버로딩 가능				------------------------
 * 				------------------------		구현된 메소드 목록
 * 			}									 (public) default void aaa(){}
 * 												 (public) static void bbb(){}
 * 											}
 * 											=> 인터페이스는 변수나 메소드가 public(연결목적 => 언제든 연결이 가능)
 * 		-----------------------------------------------------------
 * 		구현된 메소드 : [접근지정어] 리턴형 메소드명(매개변수..)
 * 		구현이 안된 메소드 : [접근지정어] abstract 리턴형 메소드명(매개변수..);
 * 
 * 		상속
 * 		interface =========> interface
 * 				   extends
 * 		interface =========> class
 * 				  implements
 * 
 * 		다중 상속
 * 		class A implements 인터페이스, 인터페이스....
 * 
 * 		------------------------------------
 * 		정적영역
 * 			Method Area / static
 * 		------------------------------------
 * 		Stack
 * 			지역변수 / 매개변수
 * 			=> 메모리 자체 관리
 * 			   {}가 종료되면 자동 소멸된다.
 * 		------------------------------------
 * 		Heap				  프로그래머 영역(GC)
 * 			객체 / 배열 / 인터페이스 / 열거형
 * 			=> 사용이 없는 경우
 * 			   null값인 경우
 * 		------------------------------------
 * 		=> 전체 관리 : JVM
 * 
 */
import java.util.*;
class A
{
	int a = 10;
	String name = "홍길동";
	public A() {}
	public A(int a)
	{
		this.a=a;
	}
}
class B extends A
{
	int b = 20;
	public B()
	{
		
	}
}
// A a = new B() ==> A에 있는 데이터만 사용, 메소드는 변경된 것만 사용
// 하위클래스에서 추가된 메소드, 변수는 사용할 수 없다
// B b = new B()
public class 정리_7장{

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		String s1 = "Hello";
		String s2 = "Hello";
		String s3 = new String("Hello");
		
		if(s1==s2)
			System.out.println("같다(참조주소)");
	}

}
