package com.sist.main;
/*
 * 		1. 네트워크 프로그램
 * 		2. 데이터베이스 프로그램** => Spring
 * 		------------------------------
 * 		데이터베이스는 데이터 저장 장소
 * 		=> 자바에서 읽기(읽어와서 메모리에 저장) => 제어
 * 		1. 메모리에 저장 : 변수 => 제어(제어문, 연산자)
 * 		2. 데이터가 많은 경우
 * 			= 같은 데이터형 : 배열
 * 			= 다른 데이터형 : 클래스
 * 		3. 클래스
 * 			= 클래스 정의 방법(객체지향프로그램 => 한개의 클래스로 만드는 것x, 클래스와 클래스의 연관관계)
 * 			
 * 			접근지정어(=> 권한)
 * 			private : 자신의 클래스에서만 사용 가능 => 은닉화(캡슐화)
 * 				ㄴ쓰는 목적 : 데이터 보호
 * 				ㄴ사용되는 위치 : 변수(클래스 속성)
 * 			default : 같은 패키지안에서만 사용 가능
 * 				ㄴ윈도우, 스레드
 * 			protected : 같은 패키지안에서만 사용 가능 + 상속을 받은 경우에는 다른 패키지에 접근 가능
 * 				ㄴ상속을 내리면 모든 변수, 메소드 사용이 가능하나 private변수는 접근 불가
 * 													------------------>이게 가능한 protected
 * 			public : 모든 클래스에 접근 가능
 * 				ㄴ클래스 : 연관관계 => 다른 클래스에서 접근이 가능해야함
 * 				ㄴ생성자 : 다른 클래스에서 메모리 할당 후 사용해야 하기 때문
 * 				ㄴ메소드 : 다른 클래스와 통신 담당하기 때문
 * 			=========> 앵간하면 private / public
 * 			접근지정어의 크기**
 * 			private < default < protected < public
 * 			=> 접근지정어의 확대는 가능하나 축소는 불가능하다(나중에 오버라이딩 할 때 다시 배움~)
 * 		
 * 		상속을 받는다 => 반복 제거 
 * 		----------------------------------------------------------------------------------------
 * 		클래스의 구성 요소 : 벤치마킹 ==> 요구사항 분석
 * 		class className
 * 		{
 * 			------------------------------------------------------------------------
 * 			속성, 필드 => 멤버변수(캡슐화) ==> 다른 클래스에서 사용이 가능하게 만든다
 * 					   ------------ 읽기 / 쓰기 메소드 => getter / setter(인스턴스 메소드)
 * 			공유변수(static) : 패턴(싱글턴) => 한개의 객체만 사용할 때
 * 							메모리 공간이 한개
 * 							공유하는 데이터가 존재할 때
 * 			------------------------------------------------------------------------
 * 			생성자
 * 				1. 클래스명과 동일
 * 				2. 멤버변수에 대한 초기화 담당
 * 				3. 생성자가 없는 경우에는 컴파일러가 자동으로 기본생성자(매개변수가 없는 생성자)를 추가해준다
 * 				4. 모든 클래스는 생성자는 1개 이상을 가지고 있다
 * 				5. 생성자는 객체를 생성할 때 호출되는 메소드
 * 					사용법) new 생성자()
 * 				6. 리턴형은 존재하지 않는다
 * 				7. 생성자는 필요시에 여러개를 만들 수 있다
 * 					오버로딩(중복메소드 정의, 한개의 메소드로 여러가지 기능을 만든다) 지원
 * 					조건
 * 						1) 메소드명이 동일해야함
 * 						2) 한개의 클래스에서 만든다
 * 						3) 매개변수의 갯수나 데이터형이 틀려야함
 * 						4) 리턴형은 관계x
 * 				8. 초기화뿐만 아니라 시작과 동시에 처리하는 일이 있을 경우 생성자 이용
 * 					ex) 윈도우 디자인, 웹 메인, 자동 로그인, 오라클 연결, 서버 연결...
 * 					=> 생성자가 가장 먼저 호출되는 메소드이기때문
 * 
 * 			객체 생성 방법
 * 				class A
 * 
 * 				1) A a = new A()
 * 				-----------------------------------------
 * 				2) A a = Class.forName("A").newInstance()
 * 				3) A a = A.newInstance()
 * 				------------------------ 리플렉션(스프링)
 * 			------------------------------------------------------------------------
 * 			메소드 : 기능을 수행, 다른 클래스와 연결
 * 			메소드 제작 방법(형식)
 * 			[접근지정어(public)][제어어] 리턴형 메소드명(매개변수목록)
 * 			{
 * 			}
 * 			1. 선언부
 * 				접근지정어 : public, default
 * 				제어어
 * 					static : public static => 객체마다 공통으로 사용되는 기능(데이터베이스 연결)
 * 					final : public final => 오버라이딩이 안되는 상태 => 수정이 불가능
 * 						ㄴMath, String, System => 모든 메소드를 그대로 가져다 씀
 * 						== 종단 메소드, 종단 클래스
 * 					abstract : 선언만 하는 메소드 => 프로그램에 맞게 구현해서 사용
 * 						ex) 버튼 클릭
 * 							=> 추상클래스 / 인터페이스**
 * 				리턴형 : 사용자 요청처리한 결과값
 * 					ㄴ한개만 사용이 가능
 * 					ㄴ여러개 값이 있는 경우에는 배열(==> 컬렉션(가변형)), 클래스
 * 					ㄴ결과값이 없는 경우는 메소드 자체에서 처리 => void
 * 				매개변수 : 사용자가 요청한 값, 여러개 사용이 가능
 * 					ㄴ매개변수는 최소화 시킨다(3개 이상 => 배열, 클래스 이용)
 * 			2. 구현부
 * 				변수가 선언이 되면 => 지역변수(메소드 종료와 동시에 사라짐)
 * 				지역변수
 * 					초기화가 되어 있지 않음(반드시 초기화 후에 사용해야한다!)
 * 			------------------------------------------------------------------------
 * 			this
 * 				클래스마다 this를 가지고 있다(static 제외)
 * 				== 자신의 객체 주소를 가지고 있다
 * 
 * 			class A
 * 			{
 * 				A(){
 * 					this가 존재
 * 					(this.)display()
 * 				}
 * 				void display()
 * 				{
 * 					this 사용 가능
 * 				}
 * 				static void aaa()
 * 				{
 * 					this가 존재하지 않는다
 * 					=> A a = new A(); => 객체 생성후에 사용
 * 				}
 * 			}
 * 			멤버변수, 멤버메소드, 생성자 => 클래스 소속
 * 			static => 클래스 소속x, 공유하는 메소드
 * 
 * 			this는 멤버변수와 지역변수의 구분 할 때 사용
 * 			-----------------------------------------------------------------------------------------
 * 			6장
 * 			- 재사용 기법
 * 			- 수정, 추가
 * 			- 클래스의 종류
 * 			-----------------
 * 			견고한 프로그램 => 재사용(상속, 포함) / 가독성(메소드) / 견고성(예외처리)
 * 			
 * 			자바 상속의 특징
 * 			- 반복 제거
 * 			- 기존의 만들어진 클래스를 확장해서 새로운 클래스를 만들어 사용 -> 재사용
 * 				ex)
 * 					class 게시판
 * 					{
 * 						글쓰기
 * 						목록
 * 						상세보기
 * 						...
 * 					}
 * 						  ↓
 * 					class 갤러리게시판 extends 게시판
 * 					{
 * 						글쓰기 => 이미지 업로드
 * 						목록 => 이미지 출력
 * 					}
 * 			- 유지보수용
 * 			- 단일 상속만 가능
 * 			- 상속 내리는 클래스 : 부모클래스, 슈퍼클래스, 베이스클래스, 상위클래스
 * 			  상속 받는 클래스 : 자식클래스, 서브클래스, 파생클래스, 하위클래스
 * 			  상속이 있는 경우 클래스의 크기가 있다(=> 형변환 존재)
 * 			  상속 내리는 클래스 > 상속 받는 클래스
 * 				class Super
 * 				class Sub extends Super
 * 
 * 				Super super = new Sub(); => 하위 클래스를 이용해 상위 클래스 생성
 * 				------------------------> 인터페이스 / 추상클래스 => 미완성된 클래스
 * 				Sub sub1 = (Sub)Super; => 형변환 후 사용
 * 
 * 				일반적으로는 클래스 = 생성자 동일
 * 				┌─────────────────────┐
 * 				│ 클래스와 생성자가 다른 경우 │
 * 				│ 클래스와 메소드를 이용	  │
 * 				└─────────────────────┘
 * 				 => 인터페이스(new를 사용하지 못하기 때문)
 * 
 * 				class A
 * 				{
 * 					int a,b;
 * 					void display(){1}
 * 				}
 * 
 * 				class B extends A
 * 				{
 * 					int c;
 * 					void display(){2}
 * 				}
 * 
 * 				A aa = new A();
 * 				aa.a / aa.b
 * 				aa.display() ==> 1
 * 				
 * 				B bb = new B();
 * 				bb.a / bb.b / bb.c
 * 				bb.display() ==> 2
 * 
 * 				A aaa = new B();
 * 				-		-------
 * 				변수는 A가 가지고 있는 변수만 사용이 가능
 * 				생성자 => 메소드 제어
 * 				== 변수는 앞에 따라가고 메소드는 뒤에 따라감
 * 				aaa.a / aaa.b / aaa.c / aaa.display() ==> 2
 * 								-----> 사용불가
 * 
 * 		}
 * 			
 */
/*class Data {
	private int a;

	public int getA() {
		return a;
	}

	public void setA(int a) {
		this.a = a;
	}
	
	
}
class Human {
	
	static Data d = new Data();
	public void getData(int a)
	{
		d.setA(a);
	}
	public void print()
	{
		System.out.println("d.a = "+d.getA());
	}
}*/

class Super {
	int a = 10;
	int b = 20;
	public void display()
	{
		System.out.println("Super가 가지고 있는 display()...");
	}
}
// 생성자, 초기화블록, static은 상속x
// private는 상속은 가능하나 접근이 불가능하다 => 가급적으로 protected 사용 || getter/setter 
class Sub extends Super {
	
}
public class 상속_1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
/*		Human h = new Human();
		h.getData(100);
		h.print();
		
		Human h1 = new Human();
		h1.getData(300);
		h1.print();
		
		h.print();
		*/
		
		Sub sub = new Sub();
		System.out.println(sub.a);
		System.out.println(sub.b);
		sub.display();
	}

}
